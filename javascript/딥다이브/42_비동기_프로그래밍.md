# 비동기 프로그래밍

## 동기 처리와 비동기 처리

1. 함수를 호출하면 함수 코드가 평가되어 함수 실행 컨텍스트가 생성됨
2. 생성된 함수 실행 컨텍스트는 <b>실행 컨텍스트 스택(콜 스택)</b>에 푸시되고 실행됨
3. 함수 코드 실행이 종료되면 함수 실행 컨텍스트는 실행 컨텍스트 스택에서 팝되어 제거됨

### Single Thread 방식

- JavaScript 엔진은 한 번에 하나의 태스크만 실행 가능
- 싱글 스레드 방식은 한 번에 하나의 태스크만 실행가능하므로 처리에 시간이 걸리는 태스크를 실행하는 경우 블로킹(작업 중단)이 발생

#### 예제 [1]

```javascript
const sleep = (func, delay) => {
  console.log("hello will be called after 5sec");
  const delayUntil = Date.now() + delay;
  while (Date.now() < delayUntil);

  func();
};

const hello = () => {
  console.log("hello");
};

const bye = () => {
  console.log("bye");
};

sleep(hello, 5000);
bye();

/*
hello will be called after 5sec
// 5초 동안 freezing
hello
bye => 이전 태스크가 종료될 때 까지 블로킹됨
*/
```

#### 예제 [2]

```javascript
const hello = () => {
  console.log("가랏 피카츄");
};

const bye = () => {
  console.log("고생했어, 돌아와 피카츄!");
};

setTimeout(hello, 5000);
bye();

/*
고생했어, 돌아와 피카츄!
(5sec after) 가랏 피카츄
*/
```

#### 예제 [1], 예제 [2] 비교!

- `setTimeout` 함수는 `sleep` 함수와 유사하게 일정 시간 경과 후 콜백함수를 호출하지만 setTimeout 함수 이후의 태스크를 블로킹하지 않고 곧바로 실행됨
- 싱행중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식을 <b>비동기</b> 처리라고 함

### 동기 처리 방식과 비동기 처리 방식의 비교

- 동기
  - 태스크를 순서대로 하나씩 처리
  - 실행 순서가 보장됨
  - 앞선 태스크 종료까지 이후 태스크들이 블로킹됨
- 비동기
  - 현재 실행중인 태스크가 종료되지 않은 상태라해도 다음 태스크를 곧바로 실행
  - 블로킹이 발생하지 않음
  - 태스크의 실행 순서가 보장되지 않음

### 비동기 함수

- 전통적으로 콜백 패턴 사용
  - 콜백 헬을 발생시켜 가독성을 나쁘게 함
  - 비동기 처리 중 발생한 에러의 예외처리가 곤란
  - 여러 개의 비동기 처리를 한 번에 처리하는 것에도 한계가 있음
- 비동기 처리 방식으로 동작하는 것
  - setTimeout, setInterval, HTTP 요청, 이벤트 핸들러
- 이벤트 루프, 태스크 큐와 깊은 관계가 있음

## 이벤트 루프와 태스크 큐

- JavaScript의 특징 중 하나는 싱글 스레드로 동작하는 것이며 따라서 한 번에 하나의 태스크만 처리가 가능함
- 브라우저를 봤을 때, 많은 태스크가 동시에 처리되는 것 처럼 느껴짐
  - JavaScript 의 동시성을 지원하는 이벤트 루프가 있기 때문!

### 이벤트 루프란?

- 브라우저에 내장되어 있는 기능 중 하나

#### 자바스크립트 엔진

- 구글의 V8 JS 엔진을 비롯한 대부분의 엔진은 크게 2개의 영역으로 구분 가능함
- 콜 스택
  - 평가 과정에서 생성된 실행 컨텍스트가 추가되고 제거되는 스택 자료구조인 실행 컨텍스트
  - 함수를 호출하면 함수 실행 컨텍스트가 콜 스택에 푸시되어 순차적으로 실행됨
  - 자바스크립트 엔진은 단 하나의 콜 스택을 사용하므로 최상위 실행 컨텍스트가 종료되어 콜 스택에서 제거되기 전까지는 어떤 태스크도 실행되지 않음
- 힙
  - 객체가 저장되는 메모리 공간
  - 콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체를 참조함
  - 메모리에 값을 저장하려면 먼저 값을 저장할 메모리 공간의 크기를 결정해야 함
    - 객체는 원시 값과는 달리 크기가 정해져 있지 않아서 할당해야 할 메모리 공간의 크기를 런타임에 결정(동적 할당)
    - 객체가 저장되는 메모리 공간인 힙은 구조화되어 있지 않다는 특징이 있음
