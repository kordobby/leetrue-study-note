# 자료구조와 알고리즘

## 🖐🏻 들어가며,

---

지난 주 금요일, CTO 님께 커피챗 요청을 드려서 고민 상담을 했는데 주된 내용으로는 같은 회사의 다른 주니어분들은 나름의 스페셜리티가 있는 것 같고 관심분야가 있어보이는데 나는 아직 그런 것이 없는 것 같은 느낌이 들어서 개인적인 피드백이나 방향성을 어떻게 잡으면 좋을지에 대해 여쭤봤었다. 바쁘신 분을 붙잡고 너무 오래 이야기한 것이 아닐까 싶긴 했지만.. 약 한시간 반동안 정말 많은 이야기를 했고 덕분에 나름의 방향성을 잡을 수 있었던 것 같다.

결론은 이것 저것 다 해보는 것이 좋다! 올라운더가 되면 더 좋기도 하겠지. 어쨌든 관심사라는 것은 지금의 나와 일주일 뒤의 나를 비교하면 얼마든지 달라질 수 있으니 이것 저것 다 해보자는 것이다. 그리고 그런 것들을 하려면 실은 새로운 것들을 접하기보다 **기본적인 것들, 근본을 공부하고 기반을 탄탄하게 다져야한다는 결론을 내릴 수 있었다.** 그래서 가끔씩 찾아오는 홍대병(ㅋㅋㅋㅋ)을 버리고 기본에 충실하고자 나름의 스터디 계획을 잡았다.

비전공자로 기본이 아주 부족한 나는 공부할 것들이 정말정말 많지만.. 일단은 자료구조부터 딥하게 파기로..! 그리고 어느정도 공부가 되면 CTO님께 찾아가서 트레이닝 시켜달라고 부탁드려볼 계획이다. 그러니까, 이번 주말부터 열심히 자료구조를 공부 시작해보자!

## ✏️ 프로그램은 자료구조와 알고리즘으로 구성된다.

---

**자료 구조는 데이터가 어떻게 저장되고 어떻게 사용되는지를 나타낸다.** 가장 단순한 자료구조는 변수로, 숫자와 문자열을 저장하기 위해 사용한다. 그리고 저장된 값을 사용하고 싶다면 변수를 사용하게 된다. 지금까지 사용해오던 배열도 자료구조이다. 배열은 데이터를 연속적으로 저장을 하고 특정 값에 접근하고 싶다면 인덱스 값을 이용해 접근하게 된다.

**알고리즘은 어떤 문제를 해결하기 위한 확실한 방법을 의미한다.** 어떠한 자료구조를 이용해서 어떤식으로 문제를 풀어나갈지에 대해 계획하고 수행하는 것이 되겠다.

어떠한 하나의 문제를 해결한다고 할 때, 문제의 해결 방법은 다양하다. 그 안에서 어떤 것이 가장 효율적일지를 찾아나가야 하겠지만. **우리가 프로그램을 작성할 때 자료구조를 선택해서 어떻게 데이터를 저장하고 사용할 것인지를 결정하고 이에 맞는 알고리즘을 통해 데이터를 가공하고 원하는 결과를 얻는 과정을 거쳐야한다.**

## 🎰 알고리즘

---

### 더 좋은 알고리즘이란?

문제를 해결할 때 더 좋은 알고리즘을 선택하는 것은 당연히 좋은 것인데 무엇이 좋은 알고리즘일까? 메모리를 더 적게 사용하는 것이 있을 것이고 메모리는 더 차지하더라도 속도가 빠른 알고리즘이 있을 수도 있다. **일반적으로는 알고리즘의 속도를 성능의 척도로 사용**하며 이를 시간복잡도라고 한다.

### 공간 복잡도

알고리즘을 프로그램으로 실행해 완료하는 데까지 필요한 총 저장 공간을 의미한다. 공간 복잡도는 필요한 고정 공간과 가변 공간을 합하여 구한다.

- 고정 공간
  - 프로그램 크기나 입출력 횟수와는 상관없이 고정적으로 필요한 저장 공간
  - 변수 및 상수를 저장하는 공간
- 가변 공간
  - 실행 과정에서 사용하는 자료와 변수를 저장하는 함수를 실행하는 데 관련 있는 정보를 저장하는 공간

### 시간 복잡도

시간 복잡도는 **“특정 알고리즘이 어떤 문제를 해결하는 데 걸리는 시간”을 의미**한다. 이 때, 알고리즘을 평가할 때는 시간을 측정하는 방식이 아닌 **코드에서 성능에 많은 영향을 주는 부분을 찾아 시간을 예측하는 방법이 사용**된다. 코드에서 성능에 많은 영향을 주는 부분은 “반복문”이 대표적인데 알고리즘을 평가할 때는 이러한 “반복문”을 찾아서 성능을 평가한다.

성능을 평가할 때는 케이스에 따라서 다르게 확인이 될 수 있다. 최선의 경우에는 한 번에 찾을 수도 있지만 최악의 경우에는 배열의 길이만큼 시간이 걸릴 수도 있다. 그렇기 때문에 경우를 나누어서 성능을 평가하게 되는데,

- 최선의 경우 : Big-Ω
- **최악의 경우 : Big-O**
- 평균의 경우 : Big-θ

이렇게 나뉘어진다. 이 중에서 가장 많이 사용하는 것은 Big-O 이다.

## 📌  Big O (점근 표기법)

---

**Big-O 표기법은 계산량이 늘어나는 척도를 나타내기 위한 것**으로 알고리즘의 복잡도를 단순화하고 간소화시킬 때 쓰인다. 아래와 같은 방법으로 시간 복잡도를 설명할 수 있게되며 아래 사진을 참고하면, **보라색으로 갈 수록 성능이 좋지 않은 케이스**가 된다.

![스크린샷 2023-03-12 오후 12.20.52.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/20571691-c87b-4021-b6fc-1b26063bddc0/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-03-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_12.20.52.png)

## 📌  시간 복잡도와 Big-O

---

### 🔍 Constant time **algorithm** (상수 시간, `O(1)` )

상수시간은 **N이 얼마나 크든 관계없이, 끝내는데 동일한 숫자의 스텝이 필요한 경우**이다. 즉 입력 데이터의 크기에 상관없이 일정한 시간이 걸리게 된다.

![constant.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9cd4ee9a-ef11-417f-ba0c-07aa72ef71f0/constant.png)

![as.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/953cd44b-d490-4814-8531-5399028b9da6/as.png)

```jsx
const example = ["피카츄", "꼬부기", "파이리", "이상해씨"];

function findOne(array) {
  console.log(array[0]); // "피카츄"
  console.log(array[1]); // "꼬부기"
}

findOne(example);
```

---

### 🔍 Logarithimic Time **algorithm** (로그 시간, `O(log n)` )

이진 탐색 등의 알고리즘을 표현할 때 사용이 된다.

이것의 **대표적인 알고리즘은 이진 검색(Binary Search Tree, BST)으로, 만약 정렬된 배열에서 특정 숫자를 찾을 때 이진 검색을 이요한다면 배열의 가운데 값과 키 값을 비교한다.**

만약 배열의 가운데 값이 키값보다 작다면, 키값보다 작은 값들은 볼 필요가 없다. 그럼 다시 없어진 배열 값을 제외한 요소들 중에서도 중간값을 찾아서 키값과 비교한다.

![ㅣㅐㅣㅓ.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c99169db-2f0e-4f9f-b9a2-ce98c920b321/ㅣㅐㅣㅓ.png)

이렇게 한 번 처리할 때 마다 검색해야하는 데이터의 양이 절반씩 떨어지는 알고리즘을 `O(log n)` 알고리즘이라고 한다. **튀르키예즈 온 더 블럭의 이용진 행님이 자주 하시는 UP & DOWN 을 떠올리면 좋을 것 같다!**

뜬금없지만.. 내가 개발자가 되기 전에 살던 세상에서의 BST 는 혈당 수치였는데.. ^^ ㅋㅋㅋㅋ이젠 이진 검색…!

```jsx
let array = [];

function log(k, s, e) {
  for (let i = s; i <= e; i++) {
    arr.push(i);
    let m = (s + e) / 2;
    if (arr[m] === k) {
      console.log(m);
    } else if (arr[m] > k) {
      return log(k, s, m - 1);
    } else {
      return log(k, m + 1, e);
    }
  }
}
```

- 이진검색 알고리즘 속도 차이 비교 그래프

![ㅠㅜ.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d32492db-f667-471b-b9c3-38f5557e74bd/ㅠㅜ.png)

![ㅣㅐㅣㅓ.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c99169db-2f0e-4f9f-b9a2-ce98c920b321/ㅣㅐㅣㅓ.png)

![ㅜㅡ,.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a0d454ec-5149-49c3-b452-5f9e7a1e6e3f/ㅜㅡ.png)

---

### 🔍 Linear Time **algorithm** (선형 시간, `O(n)` )

데이터의 input Size에 따라 Step의 계단 수가 결정이 된다.

**따라서 입력 데이터의 크기에 비례해서 처리 시간도 늘어나는 알고리즘을 표현할 때** 사용이 된다.

              `input size = n : n steps`

![선형.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/39c90fa2-de07-4095-95a1-df9cf5ff1d5c/선형.png)

아래와 같은 케이스라면, 반복문 안에서 찾고자하는 것이 배열의 가장 앞에 위치하는 경우에는 빠르게 확인이 가능하지만 요소가 마지막에 있으면 가장 오래 걸리게된다. Big-O는 가장 최악의 케이스를 보기 때문에 결국 찾고자 하는 요소가 가장 마지막에 있는 케이스로 결정이 되며 그렇기 때문에 배열의 요소만큼 시간이 늘어나게 되는 `O(n)` 으로 표현이 된다.

```jsx
const member = ["해리포터", "론", "헤르미온느", "시리우스"];

const findMember = (array) => {
  for (let i = 0; i < array.length; i++) {
    if (array[i] === "시리우스") {
      console.log("시리우스 찾았다!");
    }
  }
};

findMember(member);
```

---

### 🔍 Quadratic Time **algorithm** (2차 시간, `O(n^2)` )

2차 시간은 **입력데이터의 크기의 제곱만큼 처리 시간이 걸리는 알고리즘**을 표현할 때 사용한다. 중첩 반복(Nested Loops)이 있을 때 발생하는 케이스로, **루프 안의 루프에서 함수를 실행할 때**가 된다.

이 때의 시간 복잡도는 `Input` 의 `n^2` 로 `Input` 이 10개라면 완성하는데 100번의 스텝이 필요하게 된다.

![ㅁㄴㅎ.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7ca0948d-9756-433c-ad41-47b5f95bd7c4/ㅁㄴㅎ.png)

for문 안에 for문을 활용해서, 원하는 데이터를 구하는 함수를 작성해보자. 만약 `member` 배열의 크기가 늘어나면 늘어날 수록 반복횟수는 그에 비례해서 늘어난다. `O(n)` 보다 시간 복잡도가 훨씬 늘어날 수 있겠다. 이 때, 배열의 길이가 크지 않다면 당장의 부담은 없지만 길이가 늘어날 때마다 부담이 확 확 커진다.

```jsx
const member = ["해리포터", "론", "헤르미온느", "시리우스"];

const findPerson = (array) => {
  for (let i = 0; i < array.length; i++) {
    for (let k = 0; k < array.length; k++) {
      console.log(array[i], array[k]);
    }
  }
};

findPerson(member);
```

---

### 🔍 Exponential Complexity \*\*\*\*(기하급수적 복잡도, `O(2^n)` )

피보나치 수열을 표현한다면, `O(2^n)` 을 표현할 수 있다. 피보나치 수열은 어떻게 코드로 구현할 수 있을까?

피보나치 수열을 구하는 코드를 재귀 함수를 통해 구현한다면 아래와 같이 표현이 된다. 즉, 함수를 호출할 때마다 바로 전 숫자와 그 전 숫자를 알아야 숫자를 더하면서 앞으로 나올 숫자를 파악할 수 있다. 이렇게 매번 함수가 호출될 때마다 두 번씩 호출이 되며, 이걸 트리의 높이만큼 반복하게 된다.

이렇게 된다면, n의 제곱보다도 데이터의 증가에 따라 처리량이 현저히 늘어나는 그래프를 볼 수가 있다.

```jsx
function a(n) {
  if (n <= 0) {
    return 0;
  } else if (n === 1) {
    return 1;
  }
  return a(n - 1) + a(n - 2);
}
```

---

### 🔍  Conclusion - 선호 시간 복잡도 순서

![1ㅁㄴㅇㄹ.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f2614d1e-b672-479e-a052-9277e241dfb3/1ㅁㄴㅇㄹ.png)

- 상수 시간

![3ㅁㄴㅇ.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2b529203-ef0f-4a7b-b670-67276ed8a6c9/3ㅁㄴㅇ.png)

- 로그 시간

![4ㅈㄹㅁ.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4ff91c93-9669-4d08-af2a-7977185f244f/4ㅈㄹㅁ.png)

- 선형 시간

![ㅊㅋㅁㅇㄴ.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4153b839-7dce-42ce-bbd7-91068d5b3fa1/ㅊㅋㅁㅇㄴ.png)

- 지수 시간

## 🖐🏻 마무리

---

주말 간에 자료구조를 다 볼 수 있을 것이라는 건 자만이었다. 사실 자료구조를 개발공부를 완전 처음할 때 이후로는 다시 열어본 적이 없는데, 제대로 이해하고 넘어간 적도 없으면서 다시 공부할 생각을 하지 않았다는게 참 창피했다..하하. 그래서 이번에 공부할 때는 조금 더 제대로, 딥하게 파서 내 것으로 만들어야겠다는 생각을 했다.

인강을 듣거나 블로그 찾아가면서 공부해볼까 싶었는데 그래도 조금은 더 자세하게 설명된 것들을 보며 이해하고 싶어서 또 책을 샀다…. 책 고르는데에도 몇시간을 날려버렸네. 쨌든 처음 공부할 때는 ‘아, 이런게 있구나…’하고만 넘겼던 시간복잡도에 대해 다시 공부를 해봤는데 이번에 공부할 때는 각 시간복잡도가 어떤 연산을 할 때 볼 수 있는지에 대한 예시와 코드들도 확인해가면서 공부해보려고 했다. 앞으로 공부를 할 때도 최대한 예제 코드들을 뜯어보면서 내 것으로 만들어야겠다! 그럼, 다음은 자료구조 들어가기!

# 참고

---

- C로 배우는 쉬운 자료구조 4판 - 이지영
- 그림으로 배우는 알고리즘 - 영진닷컴
- [그림으로 쉽게 배우는 자료구조와 알고리즘 - 인프런/감자](https://www.inflearn.com/course/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B8%B0%EB%B3%B8)
- [개발자라면 이제는 알아야하는 Big O 설명해드림 - 노마드 코더 Youtube](https://www.youtube.com/watch?v=BEVnxbxBqi8&t=281s)
- [[자료구조] 시간복잡도 with JavaScript - const_p](https://overcome-the-limits.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-with-JavaScript)
- [[알고리즘] Time Complexity (시간 복잡도) - 하나몬](https://hanamon.kr/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-time-complexity-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84/)
